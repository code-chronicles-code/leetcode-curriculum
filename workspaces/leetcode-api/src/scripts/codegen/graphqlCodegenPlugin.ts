import type { PluginFunction } from "@graphql-codegen/plugin-helpers";
import dedent from "dedent";
import graphqlQueryCompress from "graphql-query-compress";
import { Kind, OperationTypeNode } from "graphql";
import invariant from "invariant";
import nullthrows from "nullthrows";
import { z } from "zod";

import { only } from "@code-chronicles/util/only";
import { spliceString } from "@code-chronicles/util/spliceString";

import { graphqlToZod } from "./graphqlToZod.ts";

const nonNegativeIntZodType = z.number().int().nonnegative();

const operationNameZodType = z.object({
  value: z.string(),
  loc: z.object({ start: nonNegativeIntZodType, end: nonNegativeIntZodType }),
});

export const plugin: PluginFunction<{}> = function plugin(schema, documents) {
  // Encode some assumptions as invariants, namely that there is a single query
  // operation in the file.
  const { document, rawSDL: unminifiedGraphQL } = only(documents);
  const definition = only(nullthrows(document).definitions);
  invariant(
    definition.kind === Kind.OPERATION_DEFINITION &&
      definition.operation === OperationTypeNode.QUERY,
    "Expected a query!",
  );

  const hasVariables = (definition?.variableDefinitions ?? []).length > 0;

  // TODO: should we call it a Zod schema instead?

  // Extract the operation name from the definition, as well as information
  // about its location in the raw, unminified GraphQL.
  const {
    value: operationName,
    loc: { start: operationNameStart, end: operationNameEnd },
  } = operationNameZodType.parse(definition.name);
  const operationNameLength = operationNameEnd - operationNameStart;
  invariant(
    operationName.length === operationNameLength,
    "Operation name length mismatch!",
  );

  // Minify the GraphQL we use for the query.
  const minifiedGraphQL = graphqlQueryCompress(
    spliceString(
      nullthrows(unminifiedGraphQL),
      operationNameStart,
      operationNameLength,
    ),
  );

  return {
    prepend: [
      dedent`
        import { z } from "zod";

        import { getGraphQLClient } from "../../getGraphQLClient.ts";
        import type * as Types from "../../graphqlTypes.generated.ts";
      ` + "\n\n",
    ],
    append: [
      dedent`
        export const QUERY = ${JSON.stringify(minifiedGraphQL)};

        export const queryResultZodType = ${graphqlToZod(nullthrows(schema.getQueryType()), definition.selectionSet)};

        export type QueryResult = z.infer<typeof queryResultZodType>;
        export type QueryVariables = ${operationName}QueryVariables;

        export async function fetchGraphQL(${hasVariables ? "variables: QueryVariables" : ""}): Promise<QueryResult> {
          const untrustedData = await getGraphQLClient().request(QUERY${hasVariables ? ", variables" : ""});

          // The type annotation serves as a TypeScript assert that the generated
          // Zod type is compatible with the types generated by GraphQL Codegen.
          const validatedData: ${operationName}Query & QueryResult = queryResultZodType.parse(untrustedData);

          return validatedData;
        }
      ` + "\n\n",
    ],
    content: "",
  };
};
